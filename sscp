#!/usr/bin/env bash

# Download this file in Windows GitBash
#  curl -Ls https://raw.github.com/rikby/sscp/master/sscp -o /usr/bin/sscp
# Global vars:
#   SSCP_RC=.sscprc     - Global resource file
#   SSCP_SSH_BIN=ssh    - SSH bin file
#   SSCP_SCP_BIN=scp    - SCP bin file
#   SSCP_EXCLUDE=.idea  - Custom exclude list.
#   SSCP_TEMP=~         - Temp directory for archive. It uses for remote servers.
#   SSCP_CONNECT=.vagrant@127.0.0.1
#                       - Connection host and user.

set -o pipefail
set -o errexit
set -o nounset
#set -o xtrace

__dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[0]}")"
readonly __dir __file

SSCP_RC=${SSCP_RC:-.sscprc}
# directory where base .sscprc file
SSCP_BASE_DIR=${SSCP_BASE_DIR:-$(cd; pwd)}
# SSH binary file
SSCP_SSH_BIN=${SSCP_SSH_BIN:-ssh}
# SCP binary file
SSCP_SCP_BIN=${SSCP_SCP_BIN:-scp}
# Default exclude list
SSCP_EXCLUDE=${SSCP_EXCLUDE:-.idea}
# Default connection
SSCP_CONNECT=${SSCP_CONNECT:-vagrant@127.0.0.1}
# Default temp directory. It uses in a remote server as well
SSCP_TEMP=${SSCP_TEMP:-'~'}
# disable using colors
SSCP_NO_COLOR=${SSCP_NO_COLOR:-}
# disable using colors
SSCP_SILENT=${SSCP_SILENT:-}

if [ '1' == "${SSCP_NO_COLOR}" ]; then
  t_red=''
  t_green=''
  t_reset=''
else
  t_red='\e[0;31m'
  t_green='\e[0;32m'
  t_reset='\e[0m'
fi

show_help () {
    cat << 'EOF'
SSCP Shell Tool v0.3.0
Fast downloader/deployer for remote servers.
It archives files by using tar and transports them using by SCP.
Commands run by using SSH connection.

Base format:
  $ sscp ACTION SOURCE_PATH TARGET_PATH

Upload/download format:
  $ sscp upload|U|download|D SOURCE_PATH TARGET_PATH \
    [-p PORT] [-e|--ignore-excluding] [--use-vcs] [-- tar options]
      LOCAL_PATH  Local path to directory or file to upload onto a remote server.
      REMOTE_PATH Remote path to directory where packed file/s should be extracted.

Test connection:
  $ sscp test
  OK

UPLOAD
Upload file or directory onto remote server. Command:
  SOURCE_PATH Local path to directory or file to upload. Be default archive
              of packed file/s will be placed to the user home directory.
  TARGET_PATH Define remote path for extracting packed remote file/s.
              It won't unpack packed remote file/s if it's not set.

DOWNLOAD
Download file or directory from remote server. Command:
  SOURCE_PATH Remote path to directory or file to download. Be default archive
              of packed file/s will be placed to the user home directory.
  TARGET_PATH Optional.
              Define local path for extracting packed remote file/s.
              It won't unpack packed remote file/s if it's not set.
              If this argument is omitted made archive will be placed into
              a current directory.

OPTIONS
  -p|--port PORT
              Define custom connection port.
              Default: 2222
  -g|--use-vcs
              Include VCS file into transition archives.
              It excludes .idea files and VCS. This option will disable
              excluding VCS files.
  -s|silent   Disable output.
  -H|--host HOST
              Connection host. It can be passed with a username.
              root@example.com
  -e|--ignore-excluding
              Ignore all default excluding.
  -h|--help   Show this help

CONNECTION PARAMETERS
You may define connection parameters in '.sscprc'.

It will be used from current directory where this command is being executed.
E.i. if you run this command from directory /var/www you may have configuration
file /var/www/.sscprc.

In the same time you can create it in home directory. ~/.sscprc

File in the current directory has higher priority the in home user directory.

Example of .sscprc:
connect='vagrant@127.0.0.1'
port='2222'
ssh_connect="ssh ${connect} -p ${port}"
remote_base_dir='/var/www'
local_base_dir='/d/home'

Anyway, you may declare .ssh/config file.
EOF
}

check_error () {
  if [ $1 != 0 ]; then
    echo -e "${t_red}error:${t_reset} "$2 > /dev/stderr
    exit $1
  fi
}

put_echo () {
  [ "${SSCP_SILENT}" != '1' ] && echo -e ${@}
}
put_printf () {
  [ "${SSCP_SILENT}" != '1' ] && printf ${@}
}

read_params () {
  # Process args

  action_type=''
  path1=''
  path2=''
  port=''

  use_vcs=0
  exclude_on=1
  create_target_path=0

  i=0
  while [ -n "${1:-}" ] && [ "${1::1}" != '-' ]; do
    (( i+=1 ))
    if [ 1 == ${i} ]; then
      # Action type: upload or download or U or D
      action_type="${1:-}"
      if [ "${action_type}" == '-h' ] || [ "${action_type}" == '--help' ]; then
        show_help
        exit
      fi
      if [ "${action_type}" == 'U' ]; then
        action_type='upload'
      fi
      if [ "${action_type}" == 'D' ]; then
        action_type='download'
      fi
      shift
    elif [ 2 == ${i} ]; then
      # Argument 1
      path1="${1}"
      shift
    elif [ 3 == ${i} ]; then
      # Argument 1
      path2="${1}"
      shift
    fi
  done

  if [ -z "${1:-}" ]; then
    return
  fi

  # Process options
  # validate and redefine options
  OPTS=`getopt -o gp:hH: -l use-vcs,port:,help,host: -- "$@"`
  eval set -- "${OPTS}"

  while true; do
    case "${1}" in
      -g|--use-vcs)
        use_vcs=1
        shift
        ;;
      -e|--ignore-excluding)
        exclude_on=0
        shift
        ;;
      -c|--create-destination)
        create_target_path=1
        shift
        ;;
      -p|--port)
        port="$2"
        shift 2
        ;;
      -H|--host)
        connect="$2"
        shift 2
        ;;
      -h|--help)
        show_help
        exit 0
        ;;
      -\?)
        show_help
        exit 1
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "${0}: unparseable option ${1}."
        exit 3
        ;;
    esac
  done

  tar_options=$@
}

define_exclude_options() {
  local exclude=''
  local path=${1}
  if [ 1 == ${exclude_on} ]; then
    exclude='--exclude='${SSCP_EXCLUDE}
    if [ 0 == ${use_vcs} ] && [[ ! "${path1}" =~ \.git[^/]*$ ]]; then
      exclude+=' --exclude-vcs'
    fi
  fi
  echo ${exclude}
}

# Init connection configuration
init_connection() {
  config_filename=${SSCP_RC}
  config_file=''
  if [ -f ${PWD}/${config_filename} ]; then
    config_file="${PWD}/${config_filename}"
  elif [ -f ${SSCP_BASE_DIR}/${config_filename} ]; then
    config_file=${SSCP_BASE_DIR}"/${config_filename}"
  fi
  ssh_connect=''
  scp_connect=''
  connect=${connect:-${SSCP_CONNECT}}
  remote_base_dir=''
  local_base_dir=''
  if [ -n "${config_file}" ]; then
    . "${config_file}"
  fi

  if [ -z "${ssh_connect}" ]; then
    ssh_connect="${SSCP_SSH_BIN} ${connect}"
    if [ -n "${port:-}" ]; then
        ssh_connect+=" -P ${port}"
    fi
  fi

  if [ -z "${scp_connect}" ]; then
    scp_connect=${SSCP_SCP_BIN}
    if [ -n "${port:-}" ]; then
      scp_connect+=" -P ${port}"
    fi
  fi
}

test_connection() {
  ${ssh_connect} 'ls -la / > /dev/null 2>&1 && echo OK'
}

deploy_target() {
  test_connection 1> /dev/null

  # validate params
  if [ -z "${path1:-}" ]; then
    check_error 3 'Empty TARGET_PATH argument.'
  fi
  if [ -z "${path2:-}" ]; then
    check_error 3 'Empty SOURCE_PATH argument.'
  fi

  if [ "${path2::1}" == '/' ]; then
    # absolute remote path
    target_dir=${path2}
  elif [ -n "${remote_base_dir}" ]; then
    # relative remote path
    target_dir=${remote_base_dir}/${path2}
  else
    # relative remote path
    target_dir=${path2}
  fi

  if [ 0 == ${create_target_path} ] && [ 0 == $(${ssh_connect} "ls -la ${target_dir} > /dev/null 2>&1 && echo 1 || echo 0") ]; then
    check_error 4 "Remote target directory ${target_dir} does not exist."
  fi

  if [ 1 == ${create_target_path} ] && [ 0 == $(${ssh_connect} "mkdir ${target_dir} -p > /dev/null 2>&1 && echo 1 || echo 0") ]; then
    check_error 4 "Could not create remote target directory '${target_dir}'."
  fi

  if [ -f ${path1} ]; then
    upload_type='f'
    source_path=${path1}
    source_dir=$(dirname ${path1})
  elif [ -d ${path1} ]; then
    upload_type='d'
    source_path=${path1}
    source_dir=${path1}
  elif [ -n  "${local_base_dir}" ] && [ -f ${local_base_dir}/${path1} ]; then
    upload_type='d'
    source_path=${local_base_dir}/${path1}
    source_dir=$(dirname ${local_base_dir}/${path1})
  elif [ -n  "${local_base_dir}" ] && [ -d ${local_base_dir}/${path1} ]; then
    upload_type='d'
    source_path=${local_base_dir}/${path1}
    source_dir=${local_base_dir}/${path1}
  else
    check_error 4 "error: Could not find source '${path1}'"
  fi

  if [ ${upload_type} = 'd' ] || [[ ! ${source_path} =~ .*\.tar\.gz$ ]]; then
    put_printf "Packing file/s..."
    if [ ${upload_type} = 'd' ]; then
      tar czf $(basename ${source_path}).tar.gz -C ${source_path} . ${exclude} ${tar_options}
    else
        tar czf $(basename ${source_path}).tar.gz ${source_path} ${exclude} ${tar_options}
    fi
    put_echo "${t_OK}"

    source_archive=$(basename ${source_path}).tar.gz
  else
    source_archive=$(basename ${source_path})
  fi

  put_printf "Uploading archive..."
  ${scp_connect} ${source_archive} ${connect}:${target_dir} && rm -f ${source_archive}
  check_error $? 'Cannot upload archive.'
  put_echo "Uploading archive...${t_OK}"

  put_printf "Unpacking archive..."
  ${ssh_connect} "cd ${target_dir} && tar xzfm ${source_archive} && rm -f ${source_archive}"
  check_error $? 'Cannot unpack archive.'
  put_echo "${t_OK}"
}

download_target() {
  # validate params
  ${ssh_connect} "ls -la ${path1} > /dev/null 2>&1"
  check_error $? "Path does '${path1}' not exist."
  if [ -n "${path2}" ] && [ ! -d "${path2}" ]; then
    check_error 4 "No such directory '${path2}'."
  fi

  target_type=$(${ssh_connect} "[ -d ${path1} ] && echo d || echo f")

  if [ ${target_type} == 'f' ]; then
    target_basename=$(basename "${path1}")
    target_to_archive=''
    download_file=${path1}
    if [[ ! "${target_basename}" =~ \.(tar|gz) ]]; then
      # ignore packing archives
      target_to_archive=$(basename "${path1}")
    fi
    target_dir=$(dirname "${path1}")
  else
    target_basename=$( basename "${path1}" )
    target_to_archive='.'
    target_dir=${path1}
  fi

  if [ -n "${target_to_archive}" ]; then
    put_printf "Packing file/s..."
    download_file="${SSCP_TEMP}/${target_basename}.tar.gz"
    ${ssh_connect} "tar cf ${SSCP_TEMP}/${target_basename}.tar.gz -C ${target_dir} ${target_to_archive} ${exclude} ${tar_options}"
    put_echo "${t_OK}"
  fi

  put_printf 'Downloading archive...'
  ${scp_connect} ${connect}:${download_file} ./
  check_error $? 'Unable to download archive.'
  if [ -n "${target_to_archive}" ]; then
    ${ssh_connect} "rm -rf ${SSCP_TEMP}/${target_basename}.tar.gz"
  fi
  put_echo "${t_OK}"

  if [ -n "${path2}" ]; then
    put_printf "Unpacking archive..."
    tar xf ./${target_basename}.tar.gz -C ${path2}
    put_echo "${t_OK}"
    rm -f ./${target_basename}.tar.gz
  else
    echo 'Archive of target file/s: './${target_basename}.tar.gz
  fi
}

process_deployment() {
  # Green "OK"
  t_OK=${t_green}'OK'${t_reset}

  # Init passed params
  read_params $@

  if [ -z "${action_type}" ]; then
    show_help
    check_error 3 'Empty action type.'
    return
  fi

  current_pwd=${PWD}

  init_connection

  if [ "${action_type}" == 'test' ]; then
    test_connection || check_error 2 "Cannot connect to the server (${connect} ${port})."
    return
  elif [ "${action_type}" == 'config-file' ]; then
    echo ${config_file}
    return
  elif [ "${action_type}" == 'show-ssh-connection' ]; then
    echo ${ssh_connect}.
    return
  elif [ "${action_type}" == 'show-vars' ]; then
    cat << EOF
SSCP_RC=${SSCP_RC}
SSCP_BASE_DIR=${SSCP_BASE_DIR}
SSCP_SSH_BIN=${SSCP_SSH_BIN}
SSCP_SCP_BIN=${SSCP_SCP_BIN}
SSCP_EXCLUDE=${SSCP_EXCLUDE}
SSCP_CONNECT=${SSCP_CONNECT}
SSCP_TEMP=${SSCP_TEMP}
SSCP_NO_COLOR=${SSCP_NO_COLOR}
SSCP_SILENT=${SSCP_SILENT}
EOF
    return
  fi

  exclude=$(define_exclude_options ${path1})

  if [ "${action_type}" == 'upload' ]; then
    deploy_target
  elif [ "${action_type}" == 'download' ]; then
    download_target
  else
    check_error 2 "Invalid action."
  fi
}

process_deployment $@

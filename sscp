#!/usr/bin/env bash

# Download this file in Windows GitBash
#  curl -Ls https://raw.github.com/rikby/sscp/master/sscp -o /usr/bin/sscp
# Global vars:
#   SSCP_RC=.sscprc    - global resource file
#   SSCP_SSH_BIN=ssh   - SSH bin file
#   SSCP_SCP_BIN=scp   - SCP bin file
#   SSCP_EXCLUDE=.idea - Custom exclude list.

set -o pipefail
set -o errexit
set -o nounset
#set -o xtrace

__dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[0]}")"
readonly __dir __file

show_help () {
    cat << 'EOF'
    UPLOAD
    Upload file or directory onto remote server. Command:
    $ sscp upload LOCAL_PATH REMOTE_PATH [-p PORT]
        LOCAL_PATH  Local path to directory or file to upload onto a remote server.
        REMOTE_PATH Remote path to directory where packed file/s should be extracted.
        -p PORT     Define custom port.
                    Default: 2222

    DOWNLOAD
    Download file or directory from remote server. Command:
    $ sscp download REMOTE_PATH [LOCAL_PATH] [-p PORT] [-e]
        REMOTE_PATH Remote path to directory or file to download.
                    Be default archive of packed file/s will be placed to the user
                    home directory.
        LOCAL_PATH (optional)
                    Define local path for extracting packed remote file/s.
                    It won't unpack packed remote file/s if it's not set.
        -p|--port PORT
                    Define custom connection port.
                    Default: 2222
        -g|--use-vcs
                    Include VCS file into transition archives.
                    It excludes .idea files and VCS. This option will disable
                    excluding VCS files.
        -e|--ignore-excluding
                    Ignore all default excluding.
        -h|--help   Show this help

    CONNECTION PARAMETERS
    You may define connection parameters in '.sscprc'.

    It will be used from current directory where this command is being executed.
    E.i. if you run this command from directory /var/www you may have configuration
    file /var/www/.sscprc.

    In the same time you can create it in home directory. ~/.sscprc

    File in the current directory has higher priority the in home user directory.

    Example of .sscprc:
    connect='vagrant@127.0.0.1'
    port='2222'
    ssh_connect="ssh ${connect} -p ${port}"
    remote_base_dir='/var/www'
    local_base_dir='/d/home'
EOF
}

SSCP_RC=${SSCP_RC:-.sscprc}
SSCP_BASE_DIR=${SSCP_BASE_DIR:-$(cd; pwd)}
SSCP_SSH_BIN=${SSCP_SSH_BIN:-ssh}
SSCP_SCP_BIN=${SSCP_SCP_BIN:-scp}
SSCP_EXCLUDE=${SSCP_EXCLUDE:-.idea}

check_error () {
    if [ $1 != 0 ]; then
      echo -e '\e[0;31m''error''\e[0m '$2
      exit $1
    fi
}

read_params () {
  # Process args
  # Action type: upload or download or U or D
  action_type="$1"
  if [ "${action_type}" == '-h' ]; then
    show_help
    exit
  fi
  if [ "${action_type}" == 'U' ]; then
    action_type='upload'
  fi
  if [ "${action_type}" == 'D' ]; then
    action_type='download'
  fi
  if [[ ! "${action_type}" =~ ^(upload|download|test)$ ]]; then
      check_error 3 'Action type can be "upload" or "download". Use help to get more information: sscp -h'
  fi
  shift

  # Argument 1
  path1="$1"
  shift
  # Argument 2
  path2=''
  if [ -n "$1" ] && [ '-' != "${1::1}" ]; then
    path2=$1
    shift
  fi

  # Process options
  # validate and redefine options
  OPTS=`getopt -o gp:h -l use-vcs,port:,help -- "$@"`
  eval set -- "${OPTS}"
  use_vcs=0
  exclude_on=1
  while true; do
    case "${1}" in
      -g|--use-vcs)
        use_vcs=1
        shift
        ;;
      -e|--ignore-excluding)
        exclude_on=0
        shift
        ;;
      -p|--port)
        port="$2"
        shift 2
        ;;
      -h|--help)
        show_help
        exit 0
        ;;
      -\?)
        show_help
        exit 1
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "${0}: unparseable option ${1}."
        exit 3
        ;;
    esac
  done
}

define_exclude_options() {
  exclude=''
  if [ 1 == ${exclude_on} ]; then
    exclude='--exclude='${SSCP_EXCLUDE}
    if [ 0 == ${use_vcs} ] && [[ ! "${path1}" =~ \.git[^/]*$ ]]; then
      exclude+=' --exclude-vcs'
    fi
  fi
}

# Init connection configuration
init_connection() {
  config_filename=${SSCP_RC}
  config_file=''
  if [ -f ${PWD}/${config_filename} ]; then
    config_file="${PWD}/${config_filename}"
  elif [ -f ${SSCP_BASE_DIR}/${config_filename} ]; then
    config_file=${SSCP_BASE_DIR}"/${config_filename}"
  fi
  ssh_connect=''
  scp_connect=''
  connect='vagrant@127.0.0.1'
  port=''
  remote_base_dir=''
  local_base_dir=''
  if [ -n "${config_file}" ]; then
    . "${config_file}"
  fi

  if [ -z "${ssh_connect}" ]; then
    ssh_connect="${SSCP_SSH_BIN} ${connect}"
    if [ -n "${port}" ]; then
        ssh_connect+=" -P ${port}"
    fi
  fi

  if [ -z "${scp_connect}" ]; then
    scp_connect=${SSCP_SCP_BIN}
    if [ -n "${port}" ]; then
      scp_connect+=" -P ${port}"
    fi
  fi
}

test_connection() {
  ${ssh_connect} 'ls -la / > /dev/null 2>&1'
  check_error $?
  echo 'OK'
}

deploy_target() {
  # validate params
  if [ -z "${path2}" ]; then
      check_error 3 'Empty REMOTE_PATH argument.'
  fi
  if [ -z "${path1}" ]; then
      check_error 3 'Empty LOCAL_PATH argument.'
  fi
  if [ "${path2::1}" == '/' ]; then
      # absolute remote path
      target_dir=${path2}
  elif [ -n "${remote_base_dir}" ]; then
      # relative remote path
      target_dir=${remote_base_dir}/${path2}
  else
      # relative remote path
      target_dir=${path2}
  fi
  ${ssh_connect} "ls -la ${target_dir} > /dev/null 2>&1"
  check_error $? "Path '${target_dir}' does not exist."

  if [ -f ${path1} ]; then
      upload_type='f'
      source_path=${path1}
      source_dir=$(dirname ${path1})
  elif [ -d ${path1} ]; then
      upload_type='d'
      source_path=${path1}
      source_dir=${path1}
  elif [ -n  "${local_base_dir}" ] && [ -f ${local_base_dir}/${path1} ]; then
      upload_type='d'
      source_path=${local_base_dir}/${path1}
      source_dir=$(dirname ${local_base_dir}/${path1})
  elif [ -n  "${local_base_dir}" ] && [ -d ${local_base_dir}/${path1} ]; then
      upload_type='d'
      source_path=${local_base_dir}/${path1}
      source_dir=${local_base_dir}/${path1}
  else
      check_error 4 "error: Could not find source '${path1}'"
  fi

  if [ ${upload_type} = 'd' ] || [[ ! ${source_path} =~ .*\.tar\.gz$ ]]; then
      printf "Packing file/s..."
      if [ ${upload_type} = 'd' ]; then
          tar czf $(basename ${source_path}).tar.gz -C ${source_path} . ${exclude}
      else
          tar czf $(basename ${source_path}).tar.gz ${source_path} ${exclude}
      fi
      check_error $?
      echo -e "${t_OK}"

      source_archive=$(basename ${source_path}).tar.gz
  else
      source_archive=$(basename ${source_path})
  fi

  printf "Uploading archive..."
  ${scp_connect} ${source_archive} ${connect}:${target_dir} && rm -f ${source_archive}
  check_error $?
  echo -e "Uploading archive...${t_OK}"

  printf "Unpacking archive..."
  ${ssh_connect} "cd ${target_dir} && tar xzfm ${source_archive} && rm -f ${source_archive}"
  check_error $?
  echo -e "${t_OK}"
}

download_target() {
  # validate params
  ${ssh_connect} "ls -la ${path1} > /dev/null 2>&1"
  check_error $? "Path does '${path1}' not exist."
  if [ -n "${path2}" ] && [ ! -d "${path2}" ]; then
      check_error 4 "No such directory '${path2}'."
  fi

  target_type=$(${ssh_connect} "[ -d ${path1} ] && echo d || echo f")
  check_error $?

  if [ ${target_type} == 'f' ]; then
      target_basename=$(basename "${path1}")
      target_to_archive=''
      download_file=${path1}
      if [[ ! "${target_basename}" =~ \.(tar|gz) ]]; then
          # ignore packing archives
          target_to_archive=$(basename "${path1}")
      fi
      target_dir=$(dirname "${path1}")
  else
      target_basename=$( basename "${path1}" )
      target_to_archive='.'
      target_dir=${path1}
  fi


  if [ -n "${target_to_archive}" ]; then
      printf "Packing file/s..."
      download_file="~/${target_basename}.tar.gz"
      ${ssh_connect} "tar cf ~/${target_basename}.tar.gz -C ${target_dir} ${target_to_archive} ${exclude}"
      check_error $? 'Cannot make archive.'
      echo -e "${t_OK}"
  fi

  printf "Downloading archive..."
  ${scp_connect} ${connect}:${download_file} ./
  check_error $? 'Unable to download archive.'
  if [ -n "${target_to_archive}" ]; then
      ${ssh_connect} "rm -rf ~/${target_basename}.tar.gz"
      check_error $? 'Cannot remove created archive on the server.'
  fi
  echo -e "${t_OK}"

  if [ -n "${path2}" ]; then
      printf "Unpacking archive..."
      tar xf ./${target_basename}.tar.gz -C ${path2}
      check_error $?
      echo -e "${t_OK}"
  else
      echo 'Archive of target file/s: './${target_basename}.tar.gz
  fi
}

process_deployment() {
  # Green "OK"
  t_OK='\e[0;32mOK\e[0m'

  # Init passed params
  read_params $@

  current_pwd=$(pwd)
  exclude=$(define_exclude_options)

  if [ ${action_type} == 'test' ]; then
    test_connection
  elif [ ${action_type} == 'upload' ]; then
    deploy_target
  elif [ ${action_type} == 'download' ]; then
    download_target
  fi
}

process_deployment $@
